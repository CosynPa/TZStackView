//
//  TZStackView.swift
//  TZStackView
//
//  Created by Tom van Zummeren on 10/06/15.
//  Copyright Â© 2015 Tom van Zummeren. All rights reserved.
//

import UIKit

private func constraintIsAutoGenerated(_ constraint: NSLayoutConstraint) -> Bool {
    let autoGenerated = constraint.identifier?.hasPrefix("IB auto generated") == true
        || String(describing: type(of: constraint)).range(of: "Prototyping") != nil

    return autoGenerated
}

private func constraintContains(_ view: UIView) -> (NSLayoutConstraint) -> Bool {
    return { ($0.firstItem as? UIView) == view || ($0.secondItem as? UIView) == view }
}

@inline(__always) private func compose<T>(_ first: @escaping (T) -> Bool, _ second: @escaping (T) -> Bool) -> (T) -> Bool {
    return { first($0) && second($0) }
}

@inline(__always) private func negate<T>(_ predicate: @escaping (T) -> Bool) -> (T) -> Bool {
    return { !predicate($0) }
}

@IBDesignable
open class TZStackView: UIView {

    open var distribution: TZStackViewDistribution = .fill {
        didSet {
            setNeedsUpdateConstraints()
        }
    }

    open var axis: UILayoutConstraintAxis = .horizontal {
        didSet {
            setNeedsUpdateConstraints()
        }
    }
    
    open var alignment: TZStackViewAlignment = .fill {
        didSet {
            setNeedsUpdateConstraints()
        }
    }
    
    @objc @IBInspectable fileprivate var axisValue: Int {
        get {
            return axis.rawValue
        }
        set {
            axis = UILayoutConstraintAxis(rawValue: newValue) ?? .horizontal
        }
    }
    
    @objc @IBInspectable fileprivate var alignmentValue: Int {
        get {
            return alignment.rawValue
        }
        set {
            alignment = TZStackViewAlignment(rawValue: newValue) ?? .fill
        }
    }
    
    @objc @IBInspectable fileprivate var distributionValue: Int {
        get {
            return distribution.rawValue
        }
        set {
            distribution = TZStackViewDistribution(rawValue: newValue) ?? .fill
        }
    }

    @objc @IBInspectable open var spacing: CGFloat = 0 {
        didSet {
            setNeedsUpdateConstraints()
        }
    }
    
    @available(iOS, unavailable, renamed: "isLayoutMarginsRelativeArrangement")
    open var layoutMarginsRelativeArrangement: Bool = false
    
    @objc @IBInspectable open var isLayoutMarginsRelativeArrangement: Bool = false {
        didSet {
            setNeedsUpdateConstraints()
        }
    }
    
    override open var layoutMargins: UIEdgeInsets {
        get {
            if #available(iOS 8, *) {
                return super.layoutMargins
            } else {
                return _layoutMargins
            }
        }
        set {
            if #available(iOS 8, *) {
                super.layoutMargins = newValue
            } else {
                _layoutMargins = newValue
                setNeedsUpdateConstraints()
            }
        }
    }
    
    fileprivate  var  _layoutMargins = UIEdgeInsets(top: 8, left: 8, bottom: 8, right: 8)

    open fileprivate(set) var arrangedSubviews: [UIView] = [] {
        didSet {
            setNeedsUpdateConstraints()
            registerHiddenListeners(oldValue)
        }
    }

    fileprivate var kvoContext = UInt8()

    fileprivate var stackViewConstraints = [NSLayoutConstraint]()
    fileprivate var subviewConstraints = [NSLayoutConstraint]()
    
    fileprivate var layoutMarginsView: _TZSpacerView?
    fileprivate var alignmentSpanner: _TZSpacerView?
    fileprivate var orderingSpanner: _TZSpacerView?
    fileprivate var distributionSpacers: [_TZSpacerView] = []
    
    fileprivate var registeredKvoSubviews = [UIView]()
    
    fileprivate var animatingToHiddenViews = [UIView]()

    public convenience init() {
        self.init(arrangedSubviews: [])
    }
    
    public init(arrangedSubviews: [UIView]) {
        super.init(frame: CGRect.zero)
        commonInit(arrangedSubviews)
    }
    
    override public init(frame: CGRect) {
        super.init(frame: frame)
        commonInit([])
    }

    required public init(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)!
        commonInit([])
    }
    
    fileprivate func commonInit(_ arrangedSubviews: [UIView]) {
        for arrangedSubview in arrangedSubviews {
            arrangedSubview.translatesAutoresizingMaskIntoConstraints = false
            addSubview(arrangedSubview)
        }

        // Closure to invoke didSet()
        { self.arrangedSubviews = arrangedSubviews }()
    }
    
    deinit {
        // This removes `hidden` value KVO observers using didSet()
        { self.arrangedSubviews = [] }()
    }

    override open func awakeFromNib() {
        super.awakeFromNib()

        // a hack, remove Interface Builder generated constraints that are not created by you
        removeConstraints(constraints.filter(constraintIsAutoGenerated))

        for aView in subviews {
            addArrangedSubview(aView)
        }
    }
    
    override open func prepareForInterfaceBuilder() {
        if #available(iOS 8.0, *) {
            super.prepareForInterfaceBuilder()
                        
            for aView in subviews {
                addArrangedSubview(aView)
            }
        }
    }

    fileprivate func registerHiddenListeners(_ previousArrangedSubviews: [UIView]) {
        for subview in previousArrangedSubviews {
            self.removeHiddenListener(subview)
        }

        for subview in arrangedSubviews {
            self.addHiddenListener(subview)
        }
    }
    
    fileprivate func addHiddenListener(_ view: UIView) {
        view.addObserver(self, forKeyPath: "hidden", options: [.new], context: &kvoContext)
        registeredKvoSubviews.append(view)
    }
    
    fileprivate func removeHiddenListener(_ view: UIView) {
        if let index = registeredKvoSubviews.index(of: view) {
            view.removeObserver(self, forKeyPath: "hidden", context: &kvoContext)
            registeredKvoSubviews.remove(at: index)
        }
    }

    open override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if let view = object as? UIView , keyPath == "hidden" {
            let hiddenCallbackKey = "TZSV-hidden-callback"
            
            let hidden = view.isHidden

            let previouseKeys = Set(view.layer.animationKeys() ?? [])
            
            if let callbackAnimation = view.layer.animation(forKey: hiddenCallbackKey) {
                (callbackAnimation.delegate as! TZFuncAnimationDelegate).cancel(callbackAnimation)
                view.layer.removeAnimation(forKey: hiddenCallbackKey)
            }
            
            // Canceling the previouse callback will reset the hidden property, so we set it back without triggering KVO
            view.layer.isHidden = hidden
            if hidden {
                animatingToHiddenViews.append(view)
            }
            
            // Perform the animation
            setNeedsUpdateConstraints()
            setNeedsLayout()
            layoutIfNeeded()
            
            let afterKeys = Set(view.layer.animationKeys() ?? [])
            let addedKeys = afterKeys.subtracting(previouseKeys)
            
            view.layer.isHidden = false // This will set view.hidden without triggering KVO
            
            let animationFinishFunc = { [weak self, weak view] () in
                view?.layer.isHidden = hidden
                if let selv = self, let strongView = view {
                    if let index = selv.animatingToHiddenViews.index(of: strongView) {
                        selv.animatingToHiddenViews.remove(at: index)
                    }
                }
            }
            
            // Try to find the animation object associated with the hidding process.
            if let hidingAnimation = addedKeys.first.flatMap({ key in view.layer.animation(forKey: key)}) {
                let callbackAnimation = CAAnimationGroup()
                callbackAnimation.animations = []
                callbackAnimation.delegate = TZFuncAnimationDelegate { _ in
                    animationFinishFunc()
                }
                animation(callbackAnimation, copyTimingFrom: hidingAnimation, superLayer: view.layer)
                
                view.layer.add(callbackAnimation, forKey: hiddenCallbackKey)
            } else {
                animationFinishFunc()
            }
        }
    }
    
    fileprivate func animation(_ animation: CAAnimation, copyTimingFrom other: CAAnimation, superLayer: CALayer) {
        // 1. When a CAAnimation is added to a layer, its beginTime will be adjusted to current time if its beginTime is 0.
        // 2. The beginTime of the animation objects added by the system, is the block animation's delay time. So if it's non zero, it should be converted to the layer's time space
        animation.beginTime = other.beginTime == 0 ? 0 : superLayer.convertTime(CACurrentMediaTime(), from: nil) + other.beginTime
        animation.duration = other.duration
        animation.speed = other.speed
        animation.timeOffset = other.timeOffset
        animation.repeatCount = other.repeatCount
        animation.repeatDuration = other.repeatDuration
        animation.autoreverses = other.autoreverses
        animation.fillMode = other.fillMode
    }
    
    open func addArrangedSubview(_ view: UIView) {
        view.translatesAutoresizingMaskIntoConstraints = false
        view.removeConstraints(view.constraints.filter(constraintIsAutoGenerated))
        addSubview(view)
        arrangedSubviews.append(view)
    }
    
    open func removeArrangedSubview(_ view: UIView) {
        if let index = arrangedSubviews.index(of: view) {
            arrangedSubviews.remove(at: index)
        }
    }

    open func insertArrangedSubview(_ view: UIView, atIndex stackIndex: Int) {
        view.translatesAutoresizingMaskIntoConstraints = false
        view.removeConstraints(view.constraints.filter(constraintIsAutoGenerated))
        addSubview(view)
        arrangedSubviews.insert(view, at: stackIndex)
    }

    override open func willRemoveSubview(_ subview: UIView) {
        removeArrangedSubview(subview)
    }

    open override func addConstraint(_ constraint: NSLayoutConstraint) {
        if !constraintIsAutoGenerated(constraint) {
            super.addConstraint(constraint)
        }
    }

    open override func addConstraints(_ constraints: [NSLayoutConstraint]) {
        super.addConstraints(constraints.filter(negate(constraintIsAutoGenerated)))
    }

    override open func updateConstraints() {
        removeConstraints(constraints.filter(constraintIsAutoGenerated))

        if let superview = superview , superview.constraints.count > 0  {
            superview.removeConstraints(superview.constraints.filter(compose(constraintIsAutoGenerated, constraintContains(self))))
        }

        removeConstraints(stackViewConstraints)
        stackViewConstraints.removeAll()

        for arrangedSubview in arrangedSubviews {
            arrangedSubview.removeConstraints(subviewConstraints)
        }
        subviewConstraints.removeAll()
        
        if let spacerView = layoutMarginsView {
            spacerView.removeFromSuperview()
            layoutMarginsView = nil
        }
        
        if let spacerView = alignmentSpanner {
            spacerView.removeFromSuperview()
            alignmentSpanner = nil
        }
        
        if let spacerView = orderingSpanner {
            spacerView.removeFromSuperview()
            orderingSpanner = nil
        }
        
        for spacerView in distributionSpacers {
            spacerView.removeFromSuperview()
        }
        distributionSpacers.removeAll()
        
        for arrangedSubview in arrangedSubviews {
            
            if alignment != .fill {
                let guideConstraint: NSLayoutConstraint
                switch axis {
                case .horizontal:
                    guideConstraint = constraint(item: arrangedSubview, attribute: .height, toItem: nil, attribute: .notAnAttribute, constant: 0, priority: 25)
                case .vertical:
                    guideConstraint = constraint(item: arrangedSubview, attribute: .width, toItem: nil, attribute: .notAnAttribute, constant: 0, priority: 25)
                }
                guideConstraint.identifier = "TZSV-ambiguity-suppression"
                subviewConstraints.append(guideConstraint)
                arrangedSubview.addConstraint(guideConstraint)
            }
            
            if isHidden(arrangedSubview) {
                let hiddenConstraint: NSLayoutConstraint
                switch axis {
                case .horizontal:
                    hiddenConstraint = constraint(item: arrangedSubview, attribute: .width, toItem: nil, attribute: .notAnAttribute, constant: 0)
                case .vertical:
                    hiddenConstraint = constraint(item: arrangedSubview, attribute: .height, toItem: nil, attribute: .notAnAttribute, constant: 0)
                }
                hiddenConstraint.identifier = "TZSV-hiding"
                subviewConstraints.append(hiddenConstraint)
                arrangedSubview.addConstraint(hiddenConstraint)
            }
        }
        
        if arrangedSubviews.count > 0 {
            if isLayoutMarginsRelativeArrangement {
                layoutMarginsView = addSpacerView("TZViewLayoutMarginsGuide")
            }
            
            if alignment != .fill || areAllViewsHidden() {
                alignmentSpanner = addSpacerView("TZSV-alignment-spanner")
            }

            if areAllViewsHidden() {
                orderingSpanner = addSpacerView("TZSV-ordering-spanner")
            }
            
            stackViewConstraints += createMatchEdgesContraints(arrangedSubviews)
            stackViewConstraints += createFirstAndLastViewMatchEdgesContraints()
            stackViewConstraints += createCanvasFitConstraints()
            
            let visibleArrangedSubviews = arrangedSubviews.filter({!self.isHidden($0)})
            
            switch distribution {
            case .fillEqually, .fill, .fillProportionally:
                if distribution == .fillEqually {
                    stackViewConstraints += createFillEquallyConstraints(arrangedSubviews, identifier: "TZSV-fill-equally")
                }
                if distribution == .fillProportionally {
                    let (someStackViewConstraints, someSubviewConstraints) = createFillProportionallyConstraints(arrangedSubviews)
                    
                    stackViewConstraints += someStackViewConstraints
                    for (owningView, constraints) in someSubviewConstraints {
                        owningView.addConstraints(constraints)
                        subviewConstraints += constraints
                    }
                }
                
                stackViewConstraints += createFillConstraints(arrangedSubviews, constant: spacing, identifier: "TZSV-spacing")
            case .equalSpacing:
                var views = [UIView]()
                
                for (index, arrangedSubview) in arrangedSubviews.filter({ !isHidden($0) }).enumerated() {
                    if index > 0 {
                        let spacerView = addSpacerView("TZSV-distributing")
                        distributionSpacers.append(spacerView)
                        views.append(spacerView)
                    }
                    views.append(arrangedSubview)
                }

                stackViewConstraints += createFillConstraints(views, constant: 0, identifier: "TZSV-distributing-edge")
                stackViewConstraints += createFillEquallyConstraints(distributionSpacers, identifier: "TZSV-fill-equally")
                stackViewConstraints += createFillConstraints(arrangedSubviews, relatedBy: .greaterThanOrEqual, constant: spacing, identifier: "TZSV-spacing")
            case .equalCentering:
                for (index, _) in visibleArrangedSubviews.enumerated() {
                    if index > 0 {
                        distributionSpacers.append(addSpacerView("TZSV-distributing"))
                    }
                }

                stackViewConstraints += createEqualCenteringConstraints(arrangedSubviews)
            }
            
            if let spanner = alignmentSpanner {
                stackViewConstraints += createSurroundingSpacerViewConstraints(spanner, views: visibleArrangedSubviews)
            }

            if let layoutMarginsView = layoutMarginsView {
                let bottomConstraint: NSLayoutConstraint
                let leftConstraint: NSLayoutConstraint
                let rightConstraint: NSLayoutConstraint
                let topConstraint: NSLayoutConstraint
                if #available(iOS 8.0, *) {
                    bottomConstraint = constraint(item: self, attribute: .bottomMargin, toItem: layoutMarginsView, attribute: .bottom)
                    leftConstraint = constraint(item: self, attribute: .leftMargin, toItem: layoutMarginsView, attribute: .left)
                    rightConstraint = constraint(item: self, attribute: .rightMargin, toItem: layoutMarginsView, attribute: .right)
                    topConstraint = constraint(item: self, attribute: .topMargin, toItem: layoutMarginsView, attribute: .top)
                } else {
                    bottomConstraint = constraint(item: self, attribute: .bottom, toItem: layoutMarginsView, attribute: .bottom, constant: _layoutMargins.bottom)
                    leftConstraint = constraint(item: self, attribute: .left, toItem: layoutMarginsView, attribute: .left, constant: -_layoutMargins.left)
                    rightConstraint = constraint(item: self, attribute: .right, toItem: layoutMarginsView, attribute: .right, constant: _layoutMargins.right)
                    topConstraint = constraint(item: self, attribute: .top, toItem: layoutMarginsView, attribute: .top, constant: -_layoutMargins.top)
                }
            
                bottomConstraint.identifier = "TZView-bottomMargin-guide-constraint"
                leftConstraint.identifier = "TZView-leftMargin-guide-constraint"
                rightConstraint.identifier = "TZView-rightMargin-guide-constraint"
                topConstraint.identifier = "TZView-topMargin-guide-constraint"
                stackViewConstraints += [bottomConstraint, leftConstraint, rightConstraint, topConstraint]
            }
            
            if axis == .horizontal {
                switch distribution {
                case .fill, .equalSpacing, .equalCentering:
                    let totalVisible = visibleArrangedSubviews.count
                    let multilineLabels = arrangedSubviews.filter { view in
                        isMultilineLabel(view)
                    }
                    
                    if  totalVisible > 0 {
                        let totalSpacing = spacing * CGFloat(totalVisible - 1)
                        
                        let ratio = CGFloat(1) / CGFloat(totalVisible)
                        let decrease = totalSpacing / CGFloat(totalVisible)
                        
                        let edgeItem = layoutMarginsView ?? self
                        
                        for label in multilineLabels {
                            stackViewConstraints.append(constraint(item: label, attribute: .width, relatedBy: .equal, toItem: edgeItem, attribute: .width, multiplier: ratio, constant: -decrease, priority: 760, identifier: "TZSV-text-width-disambiguation"))
                        }
                    } else {
                        for label in multilineLabels {
                            let aConstraint = constraint(item: label, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, constant: 0, priority: 760, identifier: "TZSV-text-width-disambiguation")
                            subviewConstraints.append(aConstraint)
                            label.addConstraint(aConstraint)
                        }
                    }
                case .fillEqually, .fillProportionally:
                    break
                }
            }
            
            addConstraints(stackViewConstraints)
        }

        super.updateConstraints()
    }

    fileprivate func addSpacerView(_ identifier: String = "") -> _TZSpacerView {
        let spacerView = _TZSpacerView()
        spacerView.translatesAutoresizingMaskIntoConstraints = false
        spacerView.identifier = identifier
        
        insertSubview(spacerView, at: 0)
        return spacerView
    }
    
    fileprivate func createCanvasFitConstraints() -> [NSLayoutConstraint] {
        func widthFitConstraint() -> NSLayoutConstraint {
            return constraint(item: self, attribute: .width, toItem: nil, attribute: .notAnAttribute, priority: 49, identifier: "TZSV-canvas-fit")
        }
        
        func heightFitConstraint() -> NSLayoutConstraint {
            return constraint(item: self, attribute: .height, toItem: nil, attribute: .notAnAttribute, priority: 49, identifier: "TZSV-canvas-fit")
        }
        
        var result = [NSLayoutConstraint]()
        
        let baselineAlignment = (alignment == .firstBaseline || alignment == .lastBaseline) && axis == .horizontal

        if baselineAlignment && !areAllViewsHidden() {
            result.append(heightFitConstraint())
        }
        
        switch distribution {
        case .fillEqually, .fill, .fillProportionally:
            break
        case .equalSpacing, .equalCentering:
            switch axis {
            case .horizontal:
                result.append(widthFitConstraint())
            case .vertical:
                result.append(heightFitConstraint())
            }
        }
        return result
    }
    
    fileprivate func createSurroundingSpacerViewConstraints(_ spacerView: UIView, views: [UIView]) -> [NSLayoutConstraint] {
        if alignment == .fill {
            return []
        }
        
        var topPriority: UILayoutPriority = 1000
        var topRelation: NSLayoutRelation = .lessThanOrEqual
        
        var bottomPriority: UILayoutPriority = 1000
        var bottomRelation: NSLayoutRelation = .greaterThanOrEqual
        
        if alignment == .top || alignment == .leading {
            topPriority = 999.5
            topRelation = .equal
        }
        
        if alignment == .bottom || alignment == .trailing {
            bottomPriority = 999.5
            bottomRelation = .equal
        }
        
        var constraints = [NSLayoutConstraint]()
        for view in views {
            switch axis {
            case .horizontal:
                constraints.append(constraint(item: spacerView, attribute: .top, relatedBy: topRelation, toItem: view, priority: topPriority, identifier: "TZSV-spanning-boundary"))
                constraints.append(constraint(item: spacerView, attribute: .bottom, relatedBy: bottomRelation, toItem: view, priority: bottomPriority, identifier: "TZSV-spanning-boundary"))
            case .vertical:
                constraints.append(constraint(item: spacerView, attribute: .leading, relatedBy: topRelation, toItem: view, priority: topPriority, identifier: "TZSV-spanning-boundary"))
                constraints.append(constraint(item: spacerView, attribute: .trailing, relatedBy: bottomRelation, toItem: view, priority: bottomPriority, identifier: "TZSV-spanning-boundary"))
            }
        }
        
        switch axis {
        case .horizontal:
            constraints.append(constraint(item: spacerView, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, constant: 0, priority: 51, identifier: "TZSV-spanning-fit"))
        case .vertical:
            constraints.append(constraint(item: spacerView, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, constant: 0, priority: 51, identifier: "TZSV-spanning-fit"))
        }

        return constraints
    }
    
    fileprivate func createFillProportionallyConstraints(_ views: [UIView]) -> (stackViewConstraints: [NSLayoutConstraint], subviewConstraints: [(owningView: UIView, [NSLayoutConstraint])]) {
        func intrinsicContentLengthOf(_ view: UIView) -> CGFloat {
            let size = view.intrinsicContentSize
            switch axis {
            case .horizontal:
                if let label = view as? UILabel , label.numberOfLines != 1 { // multiline label
                    return 0
                } else {
                    return size.width != UIViewNoIntrinsicMetric ? size.width : 0
                }
            case .vertical:
                return size.height != UIViewNoIntrinsicMetric ? size.height : 0
            }
        }
        
        let nonHiddenViews = views.filter { view in
            return !isHidden(view)
        }
        
        if nonHiddenViews.count == 0 {
            return ([], [])
        }
        
        let numberOfHiddenViews = views.count - nonHiddenViews.count
        
        let totalViewLength = nonHiddenViews
            .map { view in
                intrinsicContentLengthOf(view)
            }
            .reduce(CGFloat(0), +)
        
        let showingTotalIsSmall: Bool
        if  numberOfHiddenViews == 0 {
            switch nonHiddenViews.count {
            case 0: // not possible
                showingTotalIsSmall = false
            case 1:
                let view = nonHiddenViews[0]
                showingTotalIsSmall = intrinsicContentLengthOf(view) <= 1
            default:
                showingTotalIsSmall = totalViewLength == 0
            }
        } else {
            showingTotalIsSmall = totalViewLength <= spacing * CGFloat(numberOfHiddenViews)
        }
        
        if showingTotalIsSmall {
            return (stackViewConstraints: createFillEquallyConstraints(nonHiddenViews, identifier: "TZSV-fill-equally"), subviewConstraints: [])
        }
        
        var stackViewConstraints = [NSLayoutConstraint]()
        var subviewConstraints = [(owningView: UIView, [NSLayoutConstraint])]()

        let totalSpacing = CGFloat(nonHiddenViews.count - 1) * spacing
        let totalSize = totalViewLength + totalSpacing

        var priority: UILayoutPriority = 1000
        let countDownPriority = nonHiddenViews.count > 1
        for arrangedSubview in views {
            if countDownPriority {
                priority -= 1
            }
            
            if isHidden(arrangedSubview) {
                continue
            }

            let length = intrinsicContentLengthOf(arrangedSubview)
            if length == 0 {
                let theConstraint: NSLayoutConstraint
                switch axis {
                case .horizontal:
                    theConstraint = constraint(item: arrangedSubview, attribute: .width, toItem: nil, attribute: .notAnAttribute, constant: 0, priority: 1000)
                case .vertical:
                    theConstraint = constraint(item: arrangedSubview, attribute: .height, toItem: nil, attribute: .notAnAttribute, constant: 0, priority: 1000)
                }
                theConstraint.identifier = "TZSV-fill-proportionally"
                subviewConstraints.append((owningView: arrangedSubview, [theConstraint]))
            } else {
                // totalSize can't be zero, since nonHiddenViews.count != 0
                let multiplier = length / totalSize
                let theConstraint: NSLayoutConstraint
                switch axis {
                case .horizontal:
                    theConstraint = constraint(item: arrangedSubview, attribute: .width, toItem: self, multiplier: multiplier, priority: priority)
                case .vertical:
                    theConstraint = constraint(item: arrangedSubview, attribute: .height, toItem: self, multiplier: multiplier, priority: priority)
                }
                
                theConstraint.identifier = "TZSV-fill-proportionally"
                stackViewConstraints.append(theConstraint)
            }
        }
        
        return (stackViewConstraints, subviewConstraints)
    }
    
    // Matchs all Width or Height attributes of all given views
    fileprivate func createFillEquallyConstraints(_ views: [UIView], identifier: String, priority: UILayoutPriority = 1000) -> [NSLayoutConstraint] {
        let constraints: [NSLayoutConstraint]
        switch axis {
        case .horizontal:
            constraints = equalAttributes(views: views.filter({ !self.isHidden($0) }), attribute: .width, priority: priority)
        case .vertical:
            constraints = equalAttributes(views: views.filter({ !self.isHidden($0) }), attribute: .height, priority: priority)
        }
        constraints.forEach { $0.identifier = identifier }
        return constraints
    }
    
    // Chains together the given views using Leading/Trailing or Top/Bottom
    fileprivate func createFillConstraints(_ views: [UIView], priority: UILayoutPriority = 1000, relatedBy relation: NSLayoutRelation = .equal, constant: CGFloat, identifier: String) -> [NSLayoutConstraint] {
        var constraints = [NSLayoutConstraint]()

        var previousView: UIView?
        for view in views {
            if let previousView = previousView {
                var c: CGFloat = 0
                if !isHidden(previousView) && !isHidden(view) {
                    c = constant
                } else if isHidden(previousView) && !isHidden(view) && views.first != previousView {
                    c = (constant / 2)
                } else if isHidden(view) && !isHidden(previousView) && views.last != view {
                    c = (constant / 2)
                }
                switch axis {
                case .horizontal:
                    constraints.append(constraint(item: view, attribute: .leading, relatedBy: relation, toItem: previousView, attribute: .trailing, constant: c, priority: priority))
                    
                case .vertical:
                    constraints.append(constraint(item: view, attribute: .top, relatedBy: relation, toItem: previousView, attribute: .bottom, constant: c, priority: priority))
                }
            }
            previousView = view
        }
        
        constraints.forEach { $0.identifier = identifier }
        return constraints
    }
    
    fileprivate func createEqualCenteringConstraints(_ views: [UIView]) -> [NSLayoutConstraint] {
        var constraints = [NSLayoutConstraint]()
        
        let visibleViewsWithIndex = views.enumerated().filter { (_, view) in !isHidden(view) }
        
        for enumerationIndex in visibleViewsWithIndex.indices.dropFirst() {
            let spacerView = distributionSpacers[enumerationIndex - 1]
            let previouseView = visibleViewsWithIndex[enumerationIndex - 1].1
            let view = visibleViewsWithIndex[enumerationIndex].1
            
            switch axis {
            case .horizontal:
                constraints.append(constraint(item: previouseView, attribute: .centerX, toItem: spacerView, attribute: .leading, identifier: "TZSV-distributing-edge"))
                constraints.append(constraint(item: view, attribute: .centerX, toItem: spacerView, attribute: .trailing, identifier: "TZSV-distributing-edge"))
            case .vertical:
                constraints.append(constraint(item: previouseView, attribute: .centerY, toItem: spacerView, attribute: .top, identifier: "TZSV-distributing-edge"))
                constraints.append(constraint(item: view, attribute: .centerY, toItem: spacerView, attribute: .bottom, identifier: "TZSV-distributing-edge"))
            }
        }
        
        if let firstSpacerView = distributionSpacers.first {
            for enumerationIndex in visibleViewsWithIndex.indices.dropFirst(2) {
                let spacerView = distributionSpacers[enumerationIndex - 1]
                let viewIndex = visibleViewsWithIndex[enumerationIndex - 1].0
                
                let attribute: NSLayoutAttribute
                switch axis {
                case .horizontal:
                    attribute = .width
                case .vertical:
                    attribute = .height
                }
                
                let aConstraint = constraint(item: firstSpacerView, attribute: attribute, toItem: spacerView, attribute: attribute, priority: 150 - UILayoutPriority(viewIndex), identifier: "TZSV-fill-equally")
                constraints.append(aConstraint)
            }
        }
                
        constraints += createFillConstraints(arrangedSubviews, relatedBy: .greaterThanOrEqual, constant: spacing, identifier: "TZSV-spacing")
        
        return constraints
    }
    
    // Matches all Bottom/Top or Leading Trailing constraints of te given views and matches those attributes of the first/last view to the container
    fileprivate func createMatchEdgesContraints(_ views: [UIView]) -> [NSLayoutConstraint] {
        var constraints = [NSLayoutConstraint]()

        switch axis {
        case .horizontal:
            switch alignment {
            case .fill:
                constraints += equalAttributes(views: views, attribute: .bottom)
                constraints += equalAttributes(views: views, attribute: .top)
            case .center:
                constraints += equalAttributes(views: views, attribute: .centerY)
            case .leading:
                constraints += equalAttributes(views: views, attribute: .top)
            case .trailing:
                constraints += equalAttributes(views: views, attribute: .bottom)
            case .firstBaseline:
                if #available(iOS 8.0, *) {
                    constraints += equalAttributes(views: views, attribute: .firstBaseline)
                }
            case .lastBaseline:
                constraints += equalAttributes(views: views, attribute: .lastBaseline)
            }
            
        case .vertical:
            switch alignment {
            case .fill:
                constraints += equalAttributes(views: views, attribute: .trailing)
                constraints += equalAttributes(views: views, attribute: .leading)
            case .center:
                constraints += equalAttributes(views: views, attribute: .centerX)
            case .leading:
                constraints += equalAttributes(views: views, attribute: .leading)
            case .trailing:
                constraints += equalAttributes(views: views, attribute: .trailing)
            case .firstBaseline, .lastBaseline:
                constraints += []
            }
        }
        
        constraints.forEach { $0.identifier = "TZSV-alignment" }
        return constraints
    }
    
    fileprivate func createFirstAndLastViewMatchEdgesContraints() -> [NSLayoutConstraint] {
        
        var constraints = [NSLayoutConstraint]()
        
        let visibleViews = arrangedSubviews.filter({!self.isHidden($0)})
        let firstView = visibleViews.first
        let lastView = visibleViews.last
        
        let edgeItem = layoutMarginsView ?? self
        
        if areAllViewsHidden() {
            switch axis {
            case .horizontal:
                constraints.append(constraint(item: edgeItem, attribute: .leading, toItem: orderingSpanner!))
                constraints.append(constraint(item: edgeItem, attribute: .trailing, toItem: orderingSpanner!))
                
                constraints.append(constraint(item: edgeItem, attribute: .top, toItem: alignmentSpanner!))
                constraints.append(constraint(item: edgeItem, attribute: .bottom, toItem: alignmentSpanner!))
                
                switch alignment {
                case .center:
                    constraints.append(constraint(item: edgeItem, attribute: .centerY, toItem: alignmentSpanner!))
                default:
                    break
                }
            case .vertical:
                constraints.append(constraint(item: edgeItem, attribute: .top, toItem: orderingSpanner!))
                constraints.append(constraint(item: edgeItem, attribute: .bottom, toItem: orderingSpanner!))
                
                constraints.append(constraint(item: edgeItem, attribute: .leading, toItem: alignmentSpanner!))
                constraints.append(constraint(item: edgeItem, attribute: .trailing, toItem: alignmentSpanner!))
                
                switch alignment {
                case .center:
                    constraints.append(constraint(item: edgeItem, attribute: .centerX, toItem: alignmentSpanner!))
                default:
                    break
                }
            }
        } else {
            switch axis {
            case .horizontal:
                if let firstView = firstView {
                    constraints.append(constraint(item: edgeItem, attribute: .leading, toItem: firstView))
                }
                if let lastView = lastView {
                    constraints.append(constraint(item: edgeItem, attribute: .trailing, toItem: lastView))
                }
            case .vertical:
                if let firstView = firstView {
                    constraints.append(constraint(item: edgeItem, attribute: .top, toItem: firstView))
                }
                if let lastView = lastView {
                    constraints.append(constraint(item: edgeItem, attribute: .bottom, toItem: lastView))
                }
            }

            let firstArrangedView = arrangedSubviews.first!
            
            let topView: UIView
            var topRelation = NSLayoutRelation.equal
            
            let bottomView: UIView
            var bottomRelation = NSLayoutRelation.equal
            
            var centerView: UIView?
            
            // alignmentSpanner must be non nil when alignment is not .Fill
            switch alignment {
            case .fill:
                topView = firstArrangedView
                bottomView = firstArrangedView
            case .center:
                topView = alignmentSpanner!
                bottomView = alignmentSpanner!
                centerView = firstArrangedView
            case .leading:
                topView = firstArrangedView
                bottomView = alignmentSpanner!
            case .trailing:
                topView = alignmentSpanner!
                bottomView = firstArrangedView
            case .firstBaseline:
                switch axis {
                case .horizontal:
                    topView = firstArrangedView
                    bottomView = alignmentSpanner!
                    topRelation = .lessThanOrEqual
                case .vertical:
                    topView = alignmentSpanner!
                    bottomView = alignmentSpanner!
                }
            case .lastBaseline:
                switch axis {
                case .horizontal:
                    topView = alignmentSpanner!
                    bottomView = firstArrangedView
                    bottomRelation = .greaterThanOrEqual
                case .vertical:
                    topView = alignmentSpanner!
                    bottomView = alignmentSpanner!
                }
            }
            
            switch axis {
            case .horizontal:
                constraints.append(constraint(item: edgeItem, attribute: .top, relatedBy: topRelation, toItem: topView))
                constraints.append(constraint(item: edgeItem, attribute: .bottom, relatedBy: bottomRelation, toItem: bottomView))

                if let centerView = centerView {
                    constraints.append(constraint(item: edgeItem, attribute: .centerY, toItem: centerView))
                }
            case .vertical:
                constraints.append(constraint(item: edgeItem, attribute: .leading, relatedBy: topRelation, toItem: topView))
                constraints.append(constraint(item: edgeItem, attribute: .trailing, relatedBy: bottomRelation, toItem: bottomView))

                if let centerView = centerView  {
                    constraints.append(constraint(item: edgeItem, attribute: .centerX, toItem: centerView))
                }
            }
        }
    
        constraints.forEach { $0.identifier = "TZSV-canvas-connection" }
        return constraints
    }
    
    fileprivate func equalAttributes(views: [UIView], attribute: NSLayoutAttribute, priority: UILayoutPriority = 1000) -> [NSLayoutConstraint] {
        var constraints = [NSLayoutConstraint]()
        if views.count > 0 {
            var firstView: UIView?

            for view in views {
                if let firstView = firstView {
                    constraints.append(constraint(item: firstView, attribute: attribute, toItem: view, priority: priority))
                } else {
                    firstView = view
                }
            }
        }
        return constraints
    }

    // Convenience method to help make NSLayoutConstraint in a less verbose way
    fileprivate func constraint(item view1: AnyObject, attribute attr1: NSLayoutAttribute, relatedBy relation: NSLayoutRelation = .equal, toItem view2: AnyObject?, attribute attr2: NSLayoutAttribute? = nil, multiplier: CGFloat = 1, constant c: CGFloat = 0, priority: UILayoutPriority = 1000, identifier: String? = nil) -> NSLayoutConstraint {

        let attribute2 = attr2 != nil ? attr2! : attr1

        let constraint = NSLayoutConstraint(item: view1, attribute: attr1, relatedBy: relation, toItem: view2, attribute: attribute2, multiplier: multiplier, constant: c)
        constraint.priority = priority
        constraint.identifier = identifier
        return constraint
    }
    
    fileprivate func isHidden(_ view: UIView) -> Bool {
        if view.isHidden {
            return true
        }
        return animatingToHiddenViews.index(of: view) != nil
    }
    
    fileprivate func areAllViewsHidden() -> Bool {
        return arrangedSubviews
            .map { isHidden($0) }
            .reduce(true) { $0 && $1 }
    }
        
    fileprivate func isMultilineLabel(_ view: UIView) -> Bool {
        if let label = view as? UILabel , label.numberOfLines != 1 {
            return true
        } else {
            return false
        }
    }
    
    // Disables setting the background color to mimic an actual UIStackView which is a non-drawing view.
    override open class var layerClass: AnyClass {
        return CATransformLayer.self
    }
    
    // Suppress the warning of "changing property backgroundColor in transform-only layer, will have no effect"
    override open var backgroundColor: UIColor? {
        get {
            return nil
        }
        set {
            
        }
    }
    
    // Suppress the warning of "changing property opaque in transform-only layer, will have no effect"
    override open var isOpaque: Bool {
        get {
            return true
        }
        set {
            
        }
    }
}
